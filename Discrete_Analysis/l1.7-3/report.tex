\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: сортировка за линейное время}

Выполнила студентка группы 08-307 МАИ \textit{Усачева Елизавета}.

\subsection*{Условие}

Необходимо написать программу, осуществляющую  ввод пар ключ-значение, упорядочить их по возрастанию ключа указанным алгоритмом сортировки за линейное время и вывести отсортированную последовательность.
\begin{enumerate}
\item На каждой непустой строке входного файла располагается пара ключ-значение, затем следует знак табуляции и указано соответствующее значение. Выходные данные состоят из тех же строк, что и входные, за исключением пустых и порядка следования.
\item Вариант задания: 7-3.
\begin{itemize}
 \item[\textbf{ \it Ключ}] Автомобильные номера в формате A 999 BC (используются буквы латинского алфавита).
 \item[\textbf{ \it Значение}] Числа от 0 до $2^{64} - 1$.
\end{itemize}
\end{enumerate}

\subsection*{Метод решения}

\begin{itemize}
    \item С помощью цикла while (до наступления <<End of File>> или ввода команды окончания считывания) через стандартный ввод stdin осуществляется <<бесконечный>> ввод данных. Бесконечный в том смысле, что заранее неизвестно, сколько будет введено данных. В этом удобство данного решения.
    \item В основе метода поразрядной сортировки я использую метод сортировки подсчетом, который реализован в функции {\it RadixSort} моей программы.
    \item Хранение пар ключ-значение реализовано с помощью массива структур, которые содержат два поля: ключ и значение. Поле {\it ключ} - это массив типа {\it char} размером [7], поле {\it значение} - переменная типа {\it unsigned long long}. 
    \item Я работаю со строками от последнего символа к первому. В каждой итерации создается вспомогательный массив от 0 до 91, соответсвующий десятичным кодам ASCII. Этот массив сначала заполняется нулями. Затем, происходит проход по исходному массиву и считается количество его {\it i}-ых элементов, которое записывается в вспомогательный массив. Следующим шагом будет подсчет элементов, не превосходящих {\it j}-го в вспомогательном массиве. Затем, на основе предыдущего шага, каждый элемент исходного массива помещается на нужное место во временном массиве. И наконец, используя функцию {\it memcpy} я присваиваю исходному массиву адрес памяти, который содержит ссылку на первый элемент нового отсортированного массива.
\end{itemize}

\subsection*{Описание программы}

\begin{itemize}
    \item \textbf{radix\_sort.c}\\ 
    Основной файл, написан на языке {\it C}. Содержит в себе функцию {\it main}, функцию {\it RadixSort}, описание используемых структуры и констант. 
\end{itemize} 

\subsection*{Дневник отладки}

\begin{itemize}
    \item Самой первой проблемой было корректное считывание специфицированных данных. Я пользовалась функцией {\it scanf} с различными спецификаторами. Однако, последний символ строки всегда забивался мусором. Решением этой проблемы было принудительное установление в конец строки символа конца строки. В дальнейшем я решила использовать функцию {\it getchar}, т.к. она оказалась быстрее.
    \item Все последующие проблемы были связаны с неверной работой с динамической памятью. Происходила утечка памяти.
\end{itemize}

\subsection*{Выводы}

Данный алгоритм поразрядной сортировки основывается на методе сортировки подсчетом, который подразумевает создание вспомогательного массива. Поэтому областью применения являются данные, которые имеют определенный и конечный диапазон значений, например целые числа или, как в моем случае, символы, имеющие соответствующие им коды ASCII. В отличие от многих других алгоритмов сортировки, поразрядная сортировка не использует операцию сравнения элементов, что выгодно его отличает. Однако, при сортировке, например, длинных строк с большим диапазоном значений, в каждой итерации будет создаваться вспомогательный массив, что будет отрицательно влиять на потребление памяти. 

\end{document}